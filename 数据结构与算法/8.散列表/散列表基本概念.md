# 什么是散列表

**定义：
1. 散列表来源于数组，它借助散列函数对数组这种数据结构进行扩展，利用的是数组支持按照下标随机访问元素的特性。
2. 需要存储在散列表中的数据我们称为键，将键转化为数组下标的方法称为散列函数，散列函数的计算结果称为散列值。
3. 将数据存储在散列值对应的数组下标位置。

![[散列表.excalidraw]]

# 散列函数
**定义：以把它定义成 hash(key)，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。

例子：
```
int hash(string key){
	var hashValue = HashValueFunc();
	return hashValue;
}
```

基本要求：
* 散列函数计算得到的散列值是一个非负整数
* 如果key1=key2，那hash(key1) == hash(key2);
* 如果key1 != key2，那么hash(key1) != hash(key2);

上述要求中，第三点由于在真实情况下，几乎不可能找到，因此出现散列冲突情况。

**如何解决散列冲突？
* **开放寻址法
	 线性探测
		定义：如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。
		![[散列表线性探测.excalidraw]]
		注意点：
		 1. 查找时，如果也出现冲突，同样按照顺序向下查询，注意中间被删除的元素
		 2. 删除时，出现冲突，顺序向下查询时，如果中途的元素被删除，会出现中断层，需要在被删除元素位置加个delete标记，告诉查询方式可以跳过该区域继续向下查询。
		![[散列表线性探索删除查询.excalidraw]]
	 
	 **二次探测
		定义：跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0，hash(key)+1，hash(key)+2……而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0，hash(key)+12，hash(key)+22……
	
	 **双重散列
		 定义：不仅要使用一个散列函数。我们使用一组散列函数 hash1(key)，hash2(key)，hash3(key)……我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。

* **链表法
	定义：在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。
	![[散列表链表法excalidraw]]