# 数组基础
***
## 什么是数组

**定义：数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。**


* 线性表：线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。除了数组，链表、队列、栈等也是线性表结构。

![[Pasted image 20220802135958.png]]
![[Pasted image 20220802140013.png]]

* 连续的内存空间和相同类型的数据

QA：数组是如何实现根据下标随机访问数组元素的？

例子：int[] a = new int[10]，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。

![[Pasted image 20220802170952.png]]

计算机是通过地址来访问内存中的数据，当计算机随机访问数组中的元素时，首先会通过下面的寻址公式，计算元素的内存地址：
```

a[i]_address = base_address + i * data_type_size

```
data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。

所以数组具备快速随机访问的特性是由于可以快速计算出内存地址，然后根据内存地址进行算法访问。如果不通过下标（没有下标无法快速获取访问地址），单纯的根据排序查看（二分法），时间复杂度也不为O(1)，而是为O（logn），如下：
```
** 该代码写的不行，数组可以直接从下标获取对应数据的，主要是展示二分法的复杂性

int[] a = new int[10]

func int search(int target, array a) {
	if (a == null) {
		return -1;
	}

	int start = 0;
	int end = a.length - 1;

	while (start <= end) {
		int mid = start + (end - start) / 2;
		if (mid == target) {
			return a[mid];
		} else if (target < array[mid]) {
			end = mid - 1;
		} else {
			start = mid + 1;
		}
	}
	return -1;
}

```

## 低效的"插入"和“删除”

### 插入操作
1. 数据不需要连续情况
	比如：int[] a = new int[10]，a中的值为0，1，2，3，4，5，6，7，8，九个数字，现在需要插入一个18数字在a[5]中，可以直接采用，a[5] = 18，a[10] = 5，进行一次替换，这样复杂度就会降低。

2. 数据需要连续情况
	比如：int[] a = new int[10]，a中的值为0，1，2，3，4，5，6，7，8，九个数字，现在需要插入一个18数字在a[5]中，因为需要原本的数字不被打乱，那么能a[10] = a[9]，a[9]=a[8]......一直到a[5] = 18。这样数字的插入复杂度就会变 为O（n）

### 删除操作
1. 数据不需要连续情况
	内容与插入类似，进行换位，可以把最后一个数字换到删除的下标
2. 数据需要连续情况
	内容与删除类似，进行平移，删除下标后面的值进行移动

### 越界问题

**定义：数组本身是内存连续的，比如 int[]  a = new int[10]中，a的最大下标为9，而a[10] 这个内容本身是不存在的，但是数据是访问的内存地址，所以可能会访问到非该数组的内存地址，导致访问的内容出错。一般有GC机制的代码，会进行报错处理**


***
***QA：为什么大多数编程语言中，数组要从 0 开始编号？***

数组中的内存地址方式为：
```
a[k]_address = base_address + k * type_size
```
如果下标从1开始：
```
a[k]_address = base_address + (k-1)*type_size
```
从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。

**当然主要是根据底层算法进行判断，有些语言还支持负数下标**

