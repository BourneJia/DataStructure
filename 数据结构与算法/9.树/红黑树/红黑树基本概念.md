# 什么是平衡二叉查找树
  **定义：二叉树中任意一个节点的左右子树的高度相差不能大于 1。

![[平衡二叉树.excalidraw]]

**平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。

# 如何定义一颗“红黑树”
**红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：
* 跟节点是黑色的
* 每个叶子节点都是黑色的空节点（null），叶子节点不存储数据
* 任何相邻的节点都不能同时为红色，红色节点被黑色隔开
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

# 红黑树的高度分析
* 首先，若将红色节点从红黑树中去除，那单纯包含黑色节点的红黑树的高度比包含相同节点个数的完全二叉树的高度要小。所以去掉红色节点的“黑树”的高度也不会超过log2n。 
* 在红黑树中，红色节点不能相邻，即有一个红色节点就要至少有一个黑色节点，将它更其他红色节点隔开。 红黑树中包含最多黑色节点的路径不会超过log2n,所以加入红色节点之后，最长路径不会超过2log2n，即，红黑树的高度近似2log2n 
* 红黑树的高度只比高度平衡的AVL树的高度（log2n）仅仅大了一倍，在性能上下降的并不多。

# 红黑树受欢迎的原因
* Treap，Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也无法避免极端情况下时间复杂度的退化。尽管这种情况出现概率不大，但是对于单次操作时间非常敏感的场景来讲，它们不适用。 
* AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利有弊，AVL树为了维持这种高度平衡，要付出更多代价，每次插入，删除都要做调整，就比较复杂，耗时。所以有频繁的插入，删除操作的数据集合，使用AVL树的代价就有点高了。 
* 红黑树只是做到了近似平衡，并不是严格的平衡，所以维护平衡的成本上，要比AVL树低。